import asyncio
import time

#asyncキーワードを使って、非同期関数main()を定義します。この関数は非同期に実行される予定の処理を含みます。
async def main():
  # 現在の時刻と"Hello!"の文字列を出力します。time.ctime()は現在の時刻を文字列で返します
  #fは、f-string（フォーマット済み文字列リテラル）を意味します。Python 3.6以降で利用可能なこの機能は、文字列内に変数の内容や式の結果を直接埋め込むことができる
  #f-stringを使用すると、文字列の中で波括弧{}を使って変数名や式を囲み、その場で変数の値を文字列に埋め込んだり、式を評価したりすることができます
  print(f'{time.ctime()} Help!Async is difficult!')
  # await式を使用してasyncio.sleep(2.0)を呼び出し、非同期に2秒間プログラムの実行を停止します。この間、イベントループは他のタスクを実行することができます
  await asyncio.sleep(2.0)
  # 2秒の待機後、再び現在の時刻と"Goodbye!"の文字列を出力します
  print(f'{time.ctime()} I understand!')

#現在のイベントループを取得します。イベントループは、非同期タスクの実行を管理するためのメカニズムです。
loop = asyncio.get_event_loop()
#main()関数を非同期タスクとしてイベントループに登録します。
task = loop.create_task(main())
#イベントループを開始し、taskが完了するまで実行します。
loop.run_until_complete(task)
#実行中のすべての非同期タスクを取得します。この時点で、実行が完了していないタスクがあれば、それらがpending変数に格納されます。
pending = asyncio.all_tasks(loop=loop)
#実行中のすべてのタスクをキャンセルします。これにより、実行中のタスクが安全に終了できるようになります
for task in pending:
  task.cancel()
#キャンセルされたタスクを集約し、それらが例外を返してもプログラムがクラッシュしないようにします。
group = asyncio.gather(*pending, return_exceptions=True)
#キャンセルされたタスクの処理が完了するまで、イベントループを再度実行します。
loop.run_until_complete(group)
#イベントループを閉じて、リソースを解放します。プログラムが終了する際には、開いているイベントループを閉じることが推奨されます。
loop.close()

#補足
'''
group = asyncio.gather(*pending, return_exceptions=True)


*演算子は、Pythonで「アンパック」操作を行う際に使われます。
特に関数の引数リストで使用される場合、この演算子はイテラブル（例えばリストやタプルなど）の要素を関数に個別の引数として渡すために用いられます。

この行では、*pendingがアンパック演算子として機能しています。
pendingは、待機中（まだ完了していない）の非同期タスクを含むイテラブル（例えばリスト）です。
asyncio.gather()関数に渡される際、*演算子はpendingリスト内の全てのタスクを個別の引数として展開します。
つまり、もしpendingが[task1, task2, task3]というリストであれば、asyncio.gather(*pending, return_exceptions=True)はasyncio.gather(task1, task2, task3, return_exceptions=True)と同じ意味になります。

return_exceptions=Trueパラメータは、gather()が実行中に発生した例外を通常の戻り値として扱うよう指示します。
これにより、例外が発生してもプログラムの実行が中断されず、例外情報を後で処理できるようになります。


イベントループとは、コンピューターが何か起こるのをずっと待っていて、それが起きたら対応する動作をする仕組みのことです。たとえば、「電話が鳴ったら出る」というのをずっと繰り返しているようなものです。

コルーチンは、途中で止めて後でまた続けられる特別な種類の処理（やること）です。本を読んでいるときに、途中でお茶を飲むためにしおりを挟んで本を閉じ、お茶を飲んだ後にまた本を開いて読み続けるようなものです。

Pythonにおけるコルーチンは、非同期プログラミングをサポートするための強力な機能です。
コルーチンを使うと、長い処理や待ち時間のあるタスクを効率的に扱うことができます。
特に、Webサーバーのように多数の接続を同時に扱う必要がある場合や、データベースへの問い合わせといった待ち時間が発生する操作を行う場合に有効です。

Pythonでは、async defを使ってコルーチンを定義します。
コルーチン内ではawaitキーワードを用いて、非同期に実行されるべき他のコルーチンやタスクを待つことができます。
このawaitによって、その処理が完了するまでの間、イベントループは他のタスクに切り替えて実行を続けることができ、これにより非常に効率的な並行処理が可能になります。

例えば、Webサイトからデータをダウンロードする処理を非同期で行いたい場合、そのダウンロード処理をawaitするコルーチンを定義することで、ダウンロード中にプログラムが停止することなく、他のタスクを進めることができます。

コルーチンは単に非同期の処理を記述する方法だけでなく、Pythonのasyncioライブラリを使って、より複雑な非同期プログラミングのパターンを実現するための基礎を提供します。
'''